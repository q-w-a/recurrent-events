---
title: "Estimation of Causal Effect via Emulation of RCTs"
author: "Quinn White"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide 
    toc: true
knit: (function(input,...) {
  rmarkdown::render(input,output_dir=here::here("output"))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE, warning=FALSE,error=TRUE)

library(tidyverse)
library(here)
library(survey)
theme_c <- function(...){ 
   # font <- "Helvetica"   #assign font family up front
  #  font <- "Arial"
    theme_bw() %+replace%    #replace elements we want to change
    
    theme(
      
      #text elements
      plot.title = element_text(             #title
                 #  family = font,            #set font family
                   size = 11,                #set font size
                   face = 'bold',            #bold typeface
                   hjust = .5,
                   vjust = 3),               
      
      plot.subtitle = element_text(          #subtitle
                #   family = font,            #font family
                   size = 10,
                   hjust = .5,
                   face = 'italic',
                   vjust = 3),               #font size
      
      axis.title = element_text(             #axis titles
                #   family = font,            #font family
                   size = 10),               #font size
      
      axis.text = element_text(              #axis text
                #   family = font,            #axis famuly
                   size = 8),
      strip.text = element_text(color="white", size = 9,
                                margin=unit(c(.1,.1,.1,.1), 'cm')),
      strip.background = element_rect(fill = "#363636"),
      # t, r, b, l
      plot.margin = unit(c(1,.5,.5,.5), "cm")
      ) %+replace%
      theme(...)
   
}


```

# Set-Up 

```{r simulation-functions-biweekly}

get_X_at_k <- function(time_point, dat, n_packs) {
  # L_{k-1}
  X_prev <- dat %>% pull(paste0("X", time_point-1))
  # A_{k}
  A1_prev <- dat %>% pull(paste0("A", time_point-1, "_1"))
  # Y_{k} 
  Y_prev <- dat %>% pull(paste0("Y", time_point-1))
  
  # wolves previously - wolves killed + term (adding or subtracting one)
  # accounting for death/birth
  # more likely to be birth if Y_prev was 1 (well fed)
  # term accounting for death/birth more likely to be positive 
  
  prob_birth <- ifelse(Y_prev == 1, .7, .5)
  
  X_new <- X_prev - A1_prev + 2*rbinom(n_packs, size=1, prob_birth) - 1
  
  # if pack is less than 3 already, only stay the same or grow 
  X_new <- ifelse(X_new <= 3, X_prev + 
                  rbinom(n_packs, size=1, prob=.5), 
                  X_new)

  Xname <- paste0("X", time_point)
  
  return(dat %>% 
           bind_cols(tibble(!!Xname := X_new))
         )
}

get_outcome_at_k <- function(time_point, dat, n_packs,
                             interval_length, 
                             lambda_0=10) {
  
    # Y_{k-1}
    Y_prev <- dat %>% pull(paste0("Y", time_point-1))
    
    # X_k
    X_prev <- dat %>% pull(paste0("X", time_point))
    
     # W_k
    W_prev <- dat %>% pull(paste0("W", time_point))
    
    # most recent wolf removal 
    most_recent_treatment <- dat %>% 
      mutate(most_recent = ifelse(
      rowSums(select(., matches("A*_1"))) == 0,
           0, max.col(select(., matches("A*_1")),
                      ties.method="last"))) %>%
      pull(most_recent)
    
    A1_prev <- ifelse(most_recent_treatment==0, 0, 1)
    
    # most recent depredation event
    most_recent_depredation_event <- dat %>% 
      mutate(most_recent = ifelse(
      rowSums(select(., matches("Y"))) == 0,
           0, max.col(select(., matches("Y")),
                      ties.method="last"))) %>%
      pull(most_recent)
      
    # delay is time from most recent treatment to current time 
    # if treatment has happened 
    delay <- ifelse(most_recent_treatment != 0, 
                    (time_point - most_recent_treatment),
                    0) 
    
    A2_prev <- delay
  
   A2_effect <- case_when(A2_prev == 0  ~ 0,
                           A2_prev <= 2 ~ 7,
                           A2_prev > 2 & A2_prev <= 4  ~ 4,
                           A2_prev > 4 & A2_prev <= 12 ~ 1,
                           A2_prev > 12 ~ 0)
    
    prob_event <- plogis(

      (-10 + 
        #bigger pack -> more mouths to feed
        2.7*(X_prev/sqrt(lambda_0))
        # more likely to kill if killed before 
        +2*ifelse(Y_prev==1, 1.1, 1)  
        # behavioral effect - stronger effect if delay is small 
        - 10 * A1_prev*A2_effect
        - 5 * W_prev # +
        # less likely if take out breeding female
        # - 10 * A3_prev 
       )
        * .05 )*(plogis(interval_length)^8)*1.1
    

    Y_new <- rbinom(n_packs, size=1, prob=prob_event)
    Yname <- paste0("Y", time_point)

    dat %>% 
      bind_cols(tibble(
        !!Yname := Y_new))
}

# assumes time point is in weeks 
get_W_at_k <- function(time_point, dat, n_packs, interval_length) {
  week <- time_point*interval_length
  if(time_point*interval_length >= 52)  {
    week <- time_point*interval_length - 52
  } 
  if(week < 8 | week > 12*4){
    W <- rep(1, nrow(dat))
  } else {
    W <- rep(0, nrow(dat))
  }
    Wname <- paste0("W", time_point)
    
    dat %>% bind_cols(tibble(!!Wname := W))
  
}

# adds treatments Ak_1, Ak_2, Ak_3 to input data frame dat 
get_treatment_at_k <- function(time_point, dat, n_packs,
                               interval_length=8,
                               intervention=NULL,
                               lambda_0=10,
                               poach_harvest_only=TRUE) {
  
  # X_{k}, Y_{k}
  X_prev <- dat %>% pull(paste0("X", time_point))
  Y_prev <- dat %>% pull(paste0("Y", time_point))
  W_prev <- dat %>% pull(paste0("W", time_point))
 
  if(!poach_harvest_only){
    prob_treat <- plogis(-6.5 + 2*Y_prev + .7*(X_prev)/sqrt(lambda_0) 
                         - .5* W_prev
                           # +rnorm(n_packs,0,3)
                         )*(plogis(interval_length)^(7))*1.05
  } else{
      prob_treat <- plogis(-6 +.7*(X_prev)/sqrt(lambda_0) 
                           - .5* W_prev  
                            # + rnorm(n_packs,0,3)
                           )*(plogis(interval_length)^(7))*1.05
  }
  

  A11 <- rbinom(n_packs, 
                size=1, 
                prob=prob_treat)

  # breeding female = 2/pack_size (larger for smaller packs)
  # prob = 0 if A11=0

  if (!is.null(intervention)) {
      assigned <- intervention(dat, time_point, current_a=A11)
      A11 <- assigned %>% pull(A1)
    }

  
  y_cols_to_check <- 1:time_point
  
  y_cols_to_check <- paste0("Y", y_cols_to_check)

  
  name1 <- paste0("A", time_point, "_1")
 
  dat %>% 
    bind_cols(tibble(
      !!name1 := A11
      ))

}

```


# Simulate Data 

```{r run-simulation}

# for simplicity, suppose study start is in January 
# intervention must be a function that outputs A1, A2 (assigned treatments) 
# takes in the natural value of treatment (so can be a shift intervention)
run_simulation <- function(years=5, n_packs=30,
                           interval_length=8, 
                           intervention=NULL) {
  
  # 8 week intervals
  K <- round((years*52)/interval_length)
  
  #----------------------------------------------------------------
  # Baseline covariates: number of wolves in pack at study start 
  #----------------------------------------------------------------
  lambda_0 <- 10 
  X1 <- rpois(n_packs, lambda_0)
  # winter -> cows close to home -> safer 
  W1 <- rep(1, n_packs)
  
  # first depredation event
  # prob_event <- plogis(-4 + .3*(L0)/sqrt(lambda_0)) 
  prob_event <- plogis(-2 + .3*(X1)/sqrt(lambda_0)) * plogis(interval_length)
  Y1 <- rbinom(n_packs, size=1, prob=prob_event)
  # P1 <- rbinom(n_packs, size=1, prob=.2)
  
  #current_dat <- bind_cols(X1=X1, Y1=Y1, W1=W1, P1=P1)
  current_dat <- bind_cols(X1=X1, Y1=Y1, W1=W1)

  for (i in 1:K) {
    # cat("i=",i)
    current_dat <- get_treatment_at_k(i, 
                                      current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

    current_dat <- get_X_at_k(i+1, current_dat, n_packs)
    current_dat <- get_W_at_k(i+1, current_dat, n_packs, interval_length)
    current_dat <- get_outcome_at_k(i+1, current_dat, n_packs, interval_length)
    
  }
  
  current_dat <- get_treatment_at_k(K+1, current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

  # incorporate right truncation
  current_dat <- current_dat %>%
    rowwise() %>%
    mutate(Y_sum = sum(c_across(starts_with("Y")), 
                       na.rm = TRUE)) %>%
    ungroup() %>%
    filter(Y_sum >0) %>%
    select(-Y_sum)

  return(current_dat)

}


```

```{r get-biweekly-dat, class.source="fold-show"}

# biweekly
# current_dat <- run_simulation(years=10, 
#                               n_packs=55, 
#                               interval_length=2) %>%
#   mutate(id = row_number())



# for testing -- biweekly
current_dat <- run_simulation(years=10, 
                              n_packs=1000, 
                              interval_length=2) %>%
  mutate(id = row_number())



```

  
# Generate Counterfactuals


```{r}

get_counterfactual_mean_new <- function(years, n_packs, interval_length=2,
                                    intervention
                                    ) {
  
  dat <- run_simulation(
    years=years, 
    n_packs=n_packs, 
    interval_length=interval_length,
    intervention = intervention) 
  
  counterfactual_mean <- get_mean_4_months_after_dep_event(dat)
  
  return(counterfactual_mean)
}

# modify to make comparable -- i.e. don't treat within 6 weeks,
# then follow natural course of treatment 
# also add never treat contrast 


get_mean_4_months_after_dep_event <- function(dat) {
  
  # 1. pick out the Y columns (adjust the pattern if needed)
  Ycols <- dat %>%
    select(contains("Y")) %>%
    colnames()
  
  Ymat  <- as.matrix(dat[ , Ycols])
  nT    <- ncol(Ymat)
  
  # new matrix to store "sum of next 16 weeks" (8 2-week intervals)
  sum_next8 <- matrix(NA_real_, nrow = nrow(Ymat), ncol = nT)
  
  for (k in seq_len(nT-8)) {
    # last time points may have <16 weeks remaining
    end_k <- min(nT, k + 8)
    # cat("k=",k,", ", "end_k=", end_k, "\n")
    # cat("sum taken from", k+1, "to", end_k, "\n")
    if (k < nT) {
      fut_sum <- rowSums(Ymat[ , (k+1):end_k, drop = FALSE])
    } else {
      fut_sum <- 0
    }
    
    # only keep this sum when Y at time k is 1
    #sum_next16[ , k] <- ifelse(Ymat[ , k] == 1, fut_sum, 0)
    # or use NA instead of 0 if you prefer:
     sum_next8[ , k] <- ifelse(Ymat[ , k] == 1, fut_sum, NA)
  }
  
  sum_next8 %>%
    as.data.frame() %>% 
    pivot_longer(cols=everything()) %>%
    pull(value)%>%
    mean(na.rm=TRUE)

  
}

dont_treat_within_6_weeks_after_dep_event <- function(dat, time_point, current_a) {
  
  if(time_point > 2) {
    # if any Y_{t}, Y_{t-1}, Y_{t-2} = 1, don't treat
     y_before <- dat %>% 
       select(all_of(paste0("Y", (time_point-2):time_point))) %>%
       rowSums()
              
     A1_new = ifelse(y_before == 1, 0, current_a)

  } else if (time_point==2) {
     y_before <- dat %>% 
       select(all_of(paste0("Y", (time_point-1):time_point))) %>%
       rowSums()
     A1_new = ifelse(y_before == 1, 0, current_a)
  } else {
    y_before <- dat %>% 
       select(all_of(paste0("Y", time_point))) %>%
       rowSums()
     A1_new = ifelse(y_before == 1, 0, current_a)
  }
  return(tibble(A1=A1_new))
}

#------------------------------------------------------------------
# always treat at two weeks, don't treat within 4 months otherwise  
#------------------------------------------------------------------
d_always_treat_at_two_weeks <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     y_within_4_months <- dat %>% 
       select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
       rowSums()
    
     treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 1, treat_otherwise)

  return(tibble(A1=A1_new))
  
}


#------------------------------------------------------------------
# always treat at two weeks, natural otherwise  
#------------------------------------------------------------------
d_always_treat_at_two_weeks_natural_no_mod_2_to_6 <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     # y_within_4_months <- dat %>% 
     #   select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
     #   rowSums()
    
     # treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 1, current_a)

  return(tibble(A1=A1_new))
  
}

#------------------------------------------------------------------
# always treat at two weeks, natural otherwise  
#------------------------------------------------------------------
d_dont_treat_at_two_weeks_natural_no_mod_2_to_6 <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     # y_within_4_months <- dat %>% 
     #   select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
     #   rowSums()
    
     # treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 0, current_a)

  return(tibble(A1=A1_new))
  
}


#---------------------------------------------------------------------------------
# always treat at two weeks, don't treat 2-4 or 4-6, natural treatment otherwise
#---------------------------------------------------------------------------------
d_always_treat_at_two_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point > 2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     y_biweek_lag2 <- dat %>% 
       pull(paste0("Y", time_point-2))
     
     # treat when Y at same time point is 1 (Y1=1 => A1=1)
     # don't treat if Y_{t-1} is 1 (this implies Y1=1 => A2=0)
     # don't treat if Y_{t-2} is 1 (this implies Y1=1 => A3=0)

     A1_new = case_when(y_before == 1 ~ 1,
                        y_biweek_lag1 == 1 ~ 0,
                        y_biweek_lag2 == 1 ~ 0,
                        TRUE ~ current_a)

  } else if(time_point ==2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     
     A1_new = case_when(y_before == 1 ~ 1,
                        y_biweek_lag1 == 1 ~ 0,
                        TRUE ~ current_a)
    
  } else if(time_point ==1) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
  
     A1_new = case_when(y_before == 1 ~ 1,
                        TRUE ~ current_a)
    
  }

  return(tibble(A1=A1_new))
  
}


#-----------------------------------------------------------
# never treat within 4 months of depredation event 
#-----------------------------------------------------------
never_treat_within_4_months <- function(dat, time_point, current_a=NULL) {
  
    y_within_4_months <- dat %>% 
       select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
       rowSums()
     
    A1_new <- ifelse(y_within_4_months, 0, current_a)
     
  return(tibble(A1=A1_new))
  
}

d_never_treat <- function(dat, time_point, current_a=NULL) {

  return(tibble(A1=rep(0,nrow(dat))))
                
}

N_PACKS <- 1e4 
N_YEARS <- 10 

identity <- get_counterfactual_mean_new(N_YEARS, N_PACKS, 2, NULL)

never_treat <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, never_treat_within_4_months)

only_treat_two_weeks <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks)

# treat at 2, then don't 2-6
treat_two_weeks_then_natural <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks_natural)


# treat at 2 then natural
treat_two_weeks_then_natural_no_modification_2_to_6 <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks_natural_no_mod_2_to_6)

dont_treat_two_weeks_then_natural_no_modification_2_to_6 <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2,  d_dont_treat_at_two_weeks_natural_no_mod_2_to_6)

cat("only modifying A1, leaving all others natural",
    treat_two_weeks_then_natural_no_modification_2_to_6/dont_treat_two_weeks_then_natural_no_modification_2_to_6)


dont_treat_6_weeks_then_natural <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, dont_treat_within_6_weeks_after_dep_event)

# only_treat_two_weeks/never_treat
# only_treat_two_weeks/identity

effect_natural=treat_two_weeks_then_natural/dont_treat_6_weeks_then_natural
cat("Treat at time 1, don't treat at times 2 or 3, then natural", effect_natural, "\n")

effect_no_treat=only_treat_two_weeks/never_treat 
cat("Treat at time 1, don't treat at times 2-8", effect_no_treat, "\n")


truth <- list(effect_natural = effect_natural,
              effect_no_treat = effect_no_treat)

saveRDS(truth, here::here('data/truth_from_counterfactuals.RDS'))


```


# Modeling 

```{r reformat-dat-into-trial-format}

format_dat <- function(current_dat) {
  delta <- 8
  # 4 months = 4*4/2 = 8 2-week intervals
  confound_window <- 0
  
  n_time_points <- current_dat %>%
    select(contains("Y")) %>% 
    ncol()
  
  current_dat <- current_dat %>%
    mutate(id=row_number())
  
  row_list <- list()
  seq_names <- 1:(1+confound_window+delta-1)
  
  for (i in (1+confound_window):(n_time_points-delta)) {
    
    for (j in 1:nrow(current_dat)) {
  
      if(current_dat[j, paste0("Y",i)]==1) {
        window <- (i-confound_window):(i+delta-1)
        
        row <- current_dat[j,] %>%
          select(all_of(paste0("Y", window)), 
                 all_of(paste0("X", window)),
                 all_of(paste0("W", window)),
                 all_of(paste0("A", window, "_1"))) %>%
          mutate(id = j)
        
        colnames(row) <- c(paste0("Y",seq_names),
                           paste0("X",seq_names),
                           paste0("W", seq_names),
                           paste0("A", seq_names),
                           "id")
        
        row_list <- c(row_list,list(row))
          
        }
      }
      
    }

  df <- bind_rows(row_list)
  return(df)

}

```

```{r reformat-current-dat-into-trial-format}

#----------------------------------
# reformat data into trial format 
#----------------------------------

df <- format_dat(current_dat)

saveRDS(df, here('data/long_df.RDS'))

# delta <- 8
# 4 months = 4*4/2 = 8 2-week intervals

```

```{r ipw-and-modeling-functions}
confound_window <- 0

#-----------------------------------
# IPW weighting functions 
#-----------------------------------
get_weight_by_k <- function(k,dat) {
  
  confound_end <- confound_window+k
  
  # only A_t for t < trial start included as confounders
  treat_end <- confound_window+k-1
  
  confound_hist<- paste0(
                       c(
                       # paste0("Z", 1:confound_end),
                        paste0("W", 1:confound_end),
                        paste0("Y", 2:confound_end),
                        paste0("X", 1:confound_end)
                        ),
                        # paste0("A", 1:treat_end)),
                        collapse="+")
  confound_hist <- ifelse(k==1, "X1+W1", confound_hist)
  
  
  treat_hist <- ifelse(k==1, "1", 
                       paste0(
                         paste0("A",
                                (confound_window+1):(k-1), collapse="+")))
 
  hist <- ifelse(k==1,confound_hist,
                 paste0(confound_hist, "+", treat_hist))
  # hist <- paste0(confound_hist, "+", treat_hist)
  treat_name <- paste0("A", k)

  mod_a1_num <- glm(as.formula(paste0(treat_name, "~", treat_hist) ),
                data=dat, family=binomial)
  
  mod_a1_denom <- glm(as.formula(paste0(treat_name, "~",
                                hist) ),
                data=dat, family=binomial)
  
  cat("k=",k,"\n")
  cat("Numerator=",paste0(treat_name, "~", treat_hist), "\n")
  cat("Denominator=",paste0(treat_name, "~",
                               hist), "\n")

  
  treat_name <- paste0("A", k)
  
  pred <- dat %>%
    mutate(pred_num = predict(mod_a1_num, 
                          type="response",
               newdata=dat),
           pred_num = ifelse(dat[[treat_name]] == 1,
                         pred_num,
                         1-pred_num),
           pred_denom = predict(mod_a1_denom, 
                          type="response",
               newdata=dat),
           pred_denom = ifelse(dat[[treat_name]]==1,
                               pred_denom,
                               1-pred_denom))
  
  w <- pred$pred_num / pred$pred_denom
  return(w)
}

get_weights <- function(delta, dat) {
  
  final_w <- map(1:delta, ~get_weight_by_k(k=.x,
                                      dat=dat)) %>%
    reduce(`*`)
  
  final_w_trunc <- ifelse(final_w < quantile(final_w,.01), 
                          quantile(final_w,.01), final_w)
  
  final_w_trunc <- ifelse(final_w > quantile(final_w,.99),
                          quantile(final_w,.99), final_w_trunc)

  return(final_w_trunc)
  
}


get_treatment_effect <- function(dat, delta, model_var, only=TRUE) {
  
  w <- get_weights(delta=delta, dat=dat)
  dat$ipw <- w
  
  svy_design <- svydesign(
    ids = ~id,             # clustering variable (person-level)
    weights = ~ipw,        # your IPTW/IPCW weight
    data = dat
  )
  
  if(only){
    var <- paste0(model_var, "_only")
  } else{
    var <- model_var
  }
  
  model <- svyglm(as.formula(paste0("outcome~",var)),
                  design=svy_design, family=poisson())
  cat("model is", paste0("outcome~",var), "\n")
  ci <- confint(model) %>% 
      as.data.frame() %>%
     rename(lower=1, upper=2) %>%
    slice(-1)
     
  coef(model)[-1] %>%
    as_tibble(rownames="var") %>%
    bind_cols(ci) %>%
    mutate(across(where(is.numeric), exp))
  
}
 

df <- readRDS(here("data/long_df.RDS"))

outcome <- df %>%
     select(-Y1) %>%
     select(contains("Y")) %>%
     rowSums() 
df$outcome <- outcome 

df <- df %>%
    mutate(A1_only = A1==1 & A2==0 & A3==0,
           A2_only = A1==0 & A2==1 & A3==0,
           A3_only = A1==0 & A2==0 & A3==1,
           A1_never_treat_only = A1==1 & A2==0 & A3==0
           & A4==0 & A5 ==0 & A6== 0 & A7 == 0)

```

```{r run-weighted-models}

cat("Treat at 2 weeks, no treat at 2-6 weeks, then natural")
get_treatment_effect(df, delta=3, "A1") 
cat("Treat at 2-4 weeks, no treat otherwise within the 6 weeks, then natural")
get_treatment_effect(df, delta=3, "A2") 
cat("Treat at 4-6 weeks, no treat otherwise within the 6 weeks, then natural")
get_treatment_effect(df, delta=3, "A3") 
cat("Treat at 2-weeks, no treat otherwise in 4 month period")
get_treatment_effect(df, delta=8, "A1_never_treat") 
cat("Treat at 2-weeks, otherwise natural")
# compare setting A=1 to A=0, natural otherwise
get_treatment_effect(df, delta=1, "A1", only=FALSE) 



```

```{r,eval=FALSE}

new_df <- df %>%
  mutate(A1=1, A2=0, A3=0, A4=0,A5=0,A6=0,A7=0, A8=0)

w <- get_weights(delta=8, new_dat=new_df)

df$ipw <- w

library(survey)

svy_design <- svydesign(
  ids = ~id,             # clustering variable (person-level)
  weights = ~ipw,        # your IPTW/IPCW weight
  data = df
)

outcome <- df %>%
   select(-Y1) %>%
   select(contains("Y")) %>%
   rowSums() 
df$outcome <- outcome 

model <- svyglm(outcome~A1, design=svy_design, family=poisson())
summary(model)


# also do 1{had dep event} if time 






# pooled nb regression



```


# Data Quality Checks  {.tabset}

## Pack Size

```{r}

L_length <- current_dat %>% 
  select(contains("X")) %>%
  ncol()

current_dat %>%
  select(contains("X")) %>%
  pivot_longer(cols=everything()) %>%
  mutate(name = factor(name, 
                       levels=c(paste0("X", 1:L_length)))) %>%
  filter(name %in% paste0("X", seq(1, L_length,by=10))) %>%
  ggplot(aes(x=value)) +
  geom_histogram() + 
  facet_wrap(~name)+
  theme_c()  +
  labs(title="Distribution of the Pack Size, by Interval")

```


## Distribution of 4-month outcomes

```{r}

df %>%
  ggplot(aes(x=outcome)) +
  geom_histogram() +
  theme_c() +
  labs(x="Number of Depredation Events") 



df %>%
  select(A1,A2,A3) %>%
  pivot_longer(cols=everything()) %>%
  group_by(name) %>%
  summarize(treated=sum(value),
         not = n() - treated) %>%
  pivot_longer(2:3, names_to="treatment") %>%
  ggplot(aes(x=name, y=value, fill=treatment)) +
  geom_bar(stat="identity", position=position_dodge(1)) +
  geom_label(aes(y=value, label=value), 
             position=position_dodge(1)) +
  theme_c() +
  labs(x="",y="Count")




```


